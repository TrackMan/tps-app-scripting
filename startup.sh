#!/bin/bash
set -e
# Azure App Service startup script
# This script creates a runtime configuration file from environment variables

echo "üöÄ Starting Azure App Service configuration..."

# Debug: Show ALL environment variables that start with VITE_
echo "üîç All VITE_ Environment Variables:"
env | grep "^VITE_" | sort

# Debug: Show specific environment variables
echo "üîç Key Environment Variables:"
echo "VITE_BACKEND_BASE_URL='${VITE_BACKEND_BASE_URL:-NOT SET}'"
echo "VITE_LOGIN_BASE_URL='${VITE_LOGIN_BASE_URL:-NOT SET}'"
echo "VITE_OAUTH_WEB_CLIENT_ID='${VITE_OAUTH_WEB_CLIENT_ID:-NOT SET}'"
echo "VITE_OAUTH_WEB_CLIENT_SECRET='${VITE_OAUTH_WEB_CLIENT_SECRET:+SET}'"
echo "VITE_NODE_ENV='${VITE_NODE_ENV:-NOT SET}'"

# DEBUG: Check if file exists before writing
echo "üîç Checking if runtime-config.js exists before writing..."
ls -la /usr/share/nginx/html/runtime-config.js 2>/dev/null || echo "File doesn't exist yet"

# Force remove any existing runtime-config.js file
echo "üóëÔ∏è Removing any existing runtime-config.js..."
rm -f /usr/share/nginx/html/runtime-config.js

# Check directory permissions
echo "üîç Directory permissions:"
ls -la /usr/share/nginx/html/

# Create runtime configuration file
echo "üìÑ Creating runtime configuration..."
TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
cat > /usr/share/nginx/html/runtime-config.js << EOF
// Runtime configuration for Azure App Service - Generated: ${TIMESTAMP}
window.runtimeConfig = {
  VITE_BACKEND_BASE_URL: '${VITE_BACKEND_BASE_URL}',
  VITE_LOGIN_BASE_URL: '${VITE_LOGIN_BASE_URL}',
  VITE_OAUTH_WEB_CLIENT_ID: '${VITE_OAUTH_WEB_CLIENT_ID}',
  VITE_OAUTH_WEB_CLIENT_SECRET: '${VITE_OAUTH_WEB_CLIENT_SECRET}',
  VITE_NODE_ENV: '${VITE_NODE_ENV}',
  _generated: '${TIMESTAMP}'
};

console.log('üîß Runtime configuration loaded for Azure App Service');
console.log('üìä Config values:', window.runtimeConfig);
console.log('üïê Generated at: ${TIMESTAMP}');
EOF

echo "‚úÖ Runtime configuration created at /usr/share/nginx/html/runtime-config.js"

# DEBUG: Verify what was actually written
echo "üìÑ Runtime config file content after writing:"
cat /usr/share/nginx/html/runtime-config.js

# DEBUG: Check file permissions after writing
echo "ÔøΩ File permissions after writing:"
ls -la /usr/share/nginx/html/runtime-config.js

# DEBUG: Test file can be read by nginx user
echo "üîç Testing nginx config:"
nginx -t 2>/dev/null && echo "‚úÖ Nginx config valid" || echo "‚ùå Nginx config error"

# CRITICAL: Verify the VITE_NODE_ENV was written correctly
echo "üîç CRITICAL CHECK - Verifying VITE_NODE_ENV in file:"
grep "VITE_NODE_ENV" /usr/share/nginx/html/runtime-config.js || echo "‚ùå VITE_NODE_ENV not found in file!"

# Double-check our environment variable is still correct
echo "üîç Double-checking environment variable:"
echo "Current VITE_NODE_ENV='${VITE_NODE_ENV}'"

if grep -q "VITE_NODE_ENV: 'production'" /usr/share/nginx/html/runtime-config.js; then
    echo "‚úÖ SUCCESS: File contains production mode!"
else
    echo "‚ùå FAILURE: File does not contain production mode!"
    echo "üö® This indicates a serious problem with file writing!"
fi

echo "‚úÖ Runtime configuration setup complete!"

# Create an api-proxy location fragment so the container can forward /api requests
# to the real backend. This writes only a `location` block so the fragment can be
# included inside the main server block defined in nginx.conf.
echo "üì° Creating API proxy location fragment (/etc/nginx/conf.d/api-proxy.conf)"

# Use a single-quoted heredoc so shell variables like $host are not expanded into the file.
# We include a placeholder __BACKEND_BASE_URL__ which we safely replace below with the
# actual runtime value (trimmed of a trailing slash).
cat > /etc/nginx/conf.d/api-proxy.conf << 'EOF'
# Dynamically generated by startup.sh - proxies /api/* to the backend provided by VITE_BACKEND_BASE_URL
location /api/ {
  # Forward to the backend base url. Note: using a full URL here lets nginx
  # perform an external proxy pass to the backend host configured at runtime.
  proxy_pass __BACKEND_BASE_URL__/api/;
  proxy_set_header Host $host;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header X-Forwarded-Proto $scheme;
  proxy_http_version 1.1;
  proxy_set_header Connection '';
  proxy_buffering off; # important for SSE
  chunked_transfer_encoding off;
  proxy_cache_bypass $http_upgrade;
  proxy_read_timeout 3600s;
  proxy_send_timeout 3600s;
}
EOF

# Safely replace placeholder with the configured backend URL. Trim any trailing slash so
# resulting proxy_pass has a single /api/ suffix.
BACKEND=${VITE_BACKEND_BASE_URL:-http://127.0.0.1:4000}
# remove trailing slash if present
BACKEND=${BACKEND%/}
sed -i "s|__BACKEND_BASE_URL__|${BACKEND}|g" /etc/nginx/conf.d/api-proxy.conf

echo "‚úÖ Wrote /etc/nginx/conf.d/api-proxy.conf (proxy -> ${BACKEND}/api/)"

# Remove any default server-level configuration that may exist in /etc/nginx/conf.d
# (for example the base image's default.conf). Our custom nginx.conf expects the
# conf.d fragments to contain only `location` blocks; a top-level `server { ... }`
# in conf.d will cause nginx to error with: "'server' directive is not allowed here".
if [ -f /etc/nginx/conf.d/default.conf ]; then
  echo "‚ö†Ô∏è Removing /etc/nginx/conf.d/default.conf to avoid nested server blocks"
  rm -f /etc/nginx/conf.d/default.conf || true
fi

# Start nginx
echo "üåê Starting nginx..."
exec nginx -g "daemon off;"